// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: question.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addQuestionToGame = `-- name: AddQuestionToGame :one

INSERT INTO game_questions (
    game_id, question_id, question_order
)
VALUES (
    $1, $2, $3
)
RETURNING id, game_id, question_id, question_order
`

type AddQuestionToGameParams struct {
	GameID        uuid.UUID `json:"game_id"`
	QuestionID    uuid.UUID `json:"question_id"`
	QuestionOrder int32     `json:"question_order"`
}

// ============================================
// GAME_QUESTIONS QUERIES
// ============================================
func (q *Queries) AddQuestionToGame(ctx context.Context, arg AddQuestionToGameParams) (GameQuestion, error) {
	row := q.db.QueryRow(ctx, addQuestionToGame, arg.GameID, arg.QuestionID, arg.QuestionOrder)
	var i GameQuestion
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.QuestionID,
		&i.QuestionOrder,
	)
	return i, err
}

const addTagToQuestion = `-- name: AddTagToQuestion :exec

INSERT INTO question_tags (question_id, tag_id)
VALUES ($1, $2)
ON CONFLICT (question_id, tag_id) DO NOTHING
`

type AddTagToQuestionParams struct {
	QuestionID uuid.UUID `json:"question_id"`
	TagID      uuid.UUID `json:"tag_id"`
}

// ============================================
// QUESTION_TAGS QUERIES
// ============================================
func (q *Queries) AddTagToQuestion(ctx context.Context, arg AddTagToQuestionParams) error {
	_, err := q.db.Exec(ctx, addTagToQuestion, arg.QuestionID, arg.TagID)
	return err
}

const countCorrectAnswersInRound = `-- name: CountCorrectAnswersInRound :one
SELECT COUNT(*) FROM game_round_answers
WHERE round_id = $1 
  AND player_id = $2 
  AND is_correct = true
`

type CountCorrectAnswersInRoundParams struct {
	RoundID  uuid.UUID `json:"round_id"`
	PlayerID uuid.UUID `json:"player_id"`
}

func (q *Queries) CountCorrectAnswersInRound(ctx context.Context, arg CountCorrectAnswersInRoundParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCorrectAnswersInRound, arg.RoundID, arg.PlayerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countGameQuestions = `-- name: CountGameQuestions :one
SELECT COUNT(*) FROM game_questions
WHERE game_id = $1
`

func (q *Queries) CountGameQuestions(ctx context.Context, gameID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countGameQuestions, gameID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPlayerAnswersInRound = `-- name: CountPlayerAnswersInRound :one
SELECT COUNT(*) FROM game_round_answers
WHERE round_id = $1 AND player_id = $2
`

type CountPlayerAnswersInRoundParams struct {
	RoundID  uuid.UUID `json:"round_id"`
	PlayerID uuid.UUID `json:"player_id"`
}

func (q *Queries) CountPlayerAnswersInRound(ctx context.Context, arg CountPlayerAnswersInRoundParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPlayerAnswersInRound, arg.RoundID, arg.PlayerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestions = `-- name: CountQuestions :one
SELECT COUNT(*) FROM questions
`

func (q *Queries) CountQuestions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByTag = `-- name: CountQuestionsByTag :one
SELECT COUNT(*) FROM question_tags
WHERE tag_id = $1
`

func (q *Queries) CountQuestionsByTag(ctx context.Context, tagID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByTag, tagID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTags = `-- name: CountTags :one
SELECT COUNT(*) FROM tags
`

func (q *Queries) CountTags(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countTags)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGameRoundAnswer = `-- name: CreateGameRoundAnswer :one

INSERT INTO game_round_answers (
    round_id, player_id, question_id, selected_option, is_correct
)
VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, round_id, player_id, question_id, selected_option, is_correct, answered_at
`

type CreateGameRoundAnswerParams struct {
	RoundID        uuid.UUID `json:"round_id"`
	PlayerID       uuid.UUID `json:"player_id"`
	QuestionID     uuid.UUID `json:"question_id"`
	SelectedOption int32     `json:"selected_option"`
	IsCorrect      bool      `json:"is_correct"`
}

// ============================================
// GAME_ROUND_ANSWERS QUERIES
// ============================================
func (q *Queries) CreateGameRoundAnswer(ctx context.Context, arg CreateGameRoundAnswerParams) (GameRoundAnswer, error) {
	row := q.db.QueryRow(ctx, createGameRoundAnswer,
		arg.RoundID,
		arg.PlayerID,
		arg.QuestionID,
		arg.SelectedOption,
		arg.IsCorrect,
	)
	var i GameRoundAnswer
	err := row.Scan(
		&i.ID,
		&i.RoundID,
		&i.PlayerID,
		&i.QuestionID,
		&i.SelectedOption,
		&i.IsCorrect,
		&i.AnsweredAt,
	)
	return i, err
}

const createQuestion = `-- name: CreateQuestion :one

INSERT INTO questions (
    content, options, correct_option, explanation
)
VALUES (
    $1, $2, $3, $4
)
RETURNING id, content, options, correct_option, explanation, created_at, updated_at
`

type CreateQuestionParams struct {
	Content       string  `json:"content"`
	Options       []byte  `json:"options"`
	CorrectOption int32   `json:"correct_option"`
	Explanation   *string `json:"explanation"`
}

// ============================================
// QUESTIONS QUERIES
// ============================================
func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, createQuestion,
		arg.Content,
		arg.Options,
		arg.CorrectOption,
		arg.Explanation,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.Options,
		&i.CorrectOption,
		&i.Explanation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTag = `-- name: CreateTag :one

INSERT INTO tags (name)
VALUES ($1)
ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
RETURNING id, name, created_at
`

// ============================================
// TAGS QUERIES
// ============================================
func (q *Queries) CreateTag(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRow(ctx, createTag, name)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const deleteGameQuestions = `-- name: DeleteGameQuestions :exec
DELETE FROM game_questions
WHERE game_id = $1
`

func (q *Queries) DeleteGameQuestions(ctx context.Context, gameID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteGameQuestions, gameID)
	return err
}

const deleteGameRoundAnswer = `-- name: DeleteGameRoundAnswer :exec
DELETE FROM game_round_answers
WHERE id = $1
`

func (q *Queries) DeleteGameRoundAnswer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteGameRoundAnswer, id)
	return err
}

const deleteQuestion = `-- name: DeleteQuestion :exec
DELETE FROM questions
WHERE id = $1
`

func (q *Queries) DeleteQuestion(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteQuestion, id)
	return err
}

const deleteQuestionTags = `-- name: DeleteQuestionTags :exec
DELETE FROM question_tags
WHERE question_id = $1
`

func (q *Queries) DeleteQuestionTags(ctx context.Context, questionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteQuestionTags, questionID)
	return err
}

const deleteRoundAnswers = `-- name: DeleteRoundAnswers :exec
DELETE FROM game_round_answers
WHERE round_id = $1
`

func (q *Queries) DeleteRoundAnswers(ctx context.Context, roundID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRoundAnswers, roundID)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags
WHERE id = $1
`

func (q *Queries) DeleteTag(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTag, id)
	return err
}

const getGameQuestion = `-- name: GetGameQuestion :one
SELECT id, game_id, question_id, question_order FROM game_questions
WHERE id = $1
`

func (q *Queries) GetGameQuestion(ctx context.Context, id uuid.UUID) (GameQuestion, error) {
	row := q.db.QueryRow(ctx, getGameQuestion, id)
	var i GameQuestion
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.QuestionID,
		&i.QuestionOrder,
	)
	return i, err
}

const getGameQuestionByOrder = `-- name: GetGameQuestionByOrder :one
SELECT 
    gq.id, gq.game_id, gq.question_id, gq.question_order,
    q.content,
    q.options,
    q.correct_option,
    q.explanation
FROM game_questions gq
INNER JOIN questions q ON gq.question_id = q.id
WHERE gq.game_id = $1 AND gq.question_order = $2
`

type GetGameQuestionByOrderParams struct {
	GameID        uuid.UUID `json:"game_id"`
	QuestionOrder int32     `json:"question_order"`
}

type GetGameQuestionByOrderRow struct {
	ID            uuid.UUID `json:"id"`
	GameID        uuid.UUID `json:"game_id"`
	QuestionID    uuid.UUID `json:"question_id"`
	QuestionOrder int32     `json:"question_order"`
	Content       string    `json:"content"`
	Options       []byte    `json:"options"`
	CorrectOption int32     `json:"correct_option"`
	Explanation   *string   `json:"explanation"`
}

func (q *Queries) GetGameQuestionByOrder(ctx context.Context, arg GetGameQuestionByOrderParams) (GetGameQuestionByOrderRow, error) {
	row := q.db.QueryRow(ctx, getGameQuestionByOrder, arg.GameID, arg.QuestionOrder)
	var i GetGameQuestionByOrderRow
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.QuestionID,
		&i.QuestionOrder,
		&i.Content,
		&i.Options,
		&i.CorrectOption,
		&i.Explanation,
	)
	return i, err
}

const getGameRoundAnswer = `-- name: GetGameRoundAnswer :one
SELECT id, round_id, player_id, question_id, selected_option, is_correct, answered_at FROM game_round_answers
WHERE id = $1
`

func (q *Queries) GetGameRoundAnswer(ctx context.Context, id uuid.UUID) (GameRoundAnswer, error) {
	row := q.db.QueryRow(ctx, getGameRoundAnswer, id)
	var i GameRoundAnswer
	err := row.Scan(
		&i.ID,
		&i.RoundID,
		&i.PlayerID,
		&i.QuestionID,
		&i.SelectedOption,
		&i.IsCorrect,
		&i.AnsweredAt,
	)
	return i, err
}

const getPlayerAnswer = `-- name: GetPlayerAnswer :one
SELECT id, round_id, player_id, question_id, selected_option, is_correct, answered_at FROM game_round_answers
WHERE round_id = $1 
  AND player_id = $2 
  AND question_id = $3
`

type GetPlayerAnswerParams struct {
	RoundID    uuid.UUID `json:"round_id"`
	PlayerID   uuid.UUID `json:"player_id"`
	QuestionID uuid.UUID `json:"question_id"`
}

func (q *Queries) GetPlayerAnswer(ctx context.Context, arg GetPlayerAnswerParams) (GameRoundAnswer, error) {
	row := q.db.QueryRow(ctx, getPlayerAnswer, arg.RoundID, arg.PlayerID, arg.QuestionID)
	var i GameRoundAnswer
	err := row.Scan(
		&i.ID,
		&i.RoundID,
		&i.PlayerID,
		&i.QuestionID,
		&i.SelectedOption,
		&i.IsCorrect,
		&i.AnsweredAt,
	)
	return i, err
}

const getQuestionByID = `-- name: GetQuestionByID :one
SELECT id, content, options, correct_option, explanation, created_at, updated_at FROM questions
WHERE id = $1
`

func (q *Queries) GetQuestionByID(ctx context.Context, id uuid.UUID) (Question, error) {
	row := q.db.QueryRow(ctx, getQuestionByID, id)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.Options,
		&i.CorrectOption,
		&i.Explanation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getQuestionWithTags = `-- name: GetQuestionWithTags :one
SELECT 
    q.id, q.content, q.options, q.correct_option, q.explanation, q.created_at, q.updated_at,
    COALESCE(
        json_agg(
            json_build_object('id', t.id, 'name', t.name)
        ) FILTER (WHERE t.id IS NOT NULL),
        '[]'
    ) as tags
FROM questions q
LEFT JOIN question_tags qt ON q.id = qt.question_id
LEFT JOIN tags t ON qt.tag_id = t.id
WHERE q.id = $1
GROUP BY q.id
`

type GetQuestionWithTagsRow struct {
	ID            uuid.UUID        `json:"id"`
	Content       string           `json:"content"`
	Options       []byte           `json:"options"`
	CorrectOption int32            `json:"correct_option"`
	Explanation   *string          `json:"explanation"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	Tags          interface{}      `json:"tags"`
}

func (q *Queries) GetQuestionWithTags(ctx context.Context, questionID uuid.UUID) (GetQuestionWithTagsRow, error) {
	row := q.db.QueryRow(ctx, getQuestionWithTags, questionID)
	var i GetQuestionWithTagsRow
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.Options,
		&i.CorrectOption,
		&i.Explanation,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Tags,
	)
	return i, err
}

const getRoundStatistics = `-- name: GetRoundStatistics :one
SELECT 
    COUNT(*) as total_answers,
    COUNT(*) FILTER (WHERE is_correct = true) as correct_answers,
    COUNT(*) FILTER (WHERE is_correct = false) as incorrect_answers,
    AVG(EXTRACT(EPOCH FROM (answered_at - 
        (SELECT started_at FROM game_round WHERE game_round.id = $1)
    ))) as average_response_time
FROM game_round_answers
WHERE round_id = $1
`

type GetRoundStatisticsRow struct {
	TotalAnswers        int64   `json:"total_answers"`
	CorrectAnswers      int64   `json:"correct_answers"`
	IncorrectAnswers    int64   `json:"incorrect_answers"`
	AverageResponseTime float64 `json:"average_response_time"`
}

func (q *Queries) GetRoundStatistics(ctx context.Context, roundID uuid.UUID) (GetRoundStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getRoundStatistics, roundID)
	var i GetRoundStatisticsRow
	err := row.Scan(
		&i.TotalAnswers,
		&i.CorrectAnswers,
		&i.IncorrectAnswers,
		&i.AverageResponseTime,
	)
	return i, err
}

const getTagByID = `-- name: GetTagByID :one
SELECT id, name, created_at FROM tags
WHERE id = $1
`

func (q *Queries) GetTagByID(ctx context.Context, id uuid.UUID) (Tag, error) {
	row := q.db.QueryRow(ctx, getTagByID, id)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const getTagByName = `-- name: GetTagByName :one
SELECT id, name, created_at FROM tags
WHERE name = $1
`

func (q *Queries) GetTagByName(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRow(ctx, getTagByName, name)
	var i Tag
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const listGameQuestions = `-- name: ListGameQuestions :many
SELECT 
    gq.id, gq.game_id, gq.question_id, gq.question_order,
    q.content,
    q.options,
    q.correct_option,
    q.explanation
FROM game_questions gq
INNER JOIN questions q ON gq.question_id = q.id
WHERE gq.game_id = $1
ORDER BY gq.question_order
`

type ListGameQuestionsRow struct {
	ID            uuid.UUID `json:"id"`
	GameID        uuid.UUID `json:"game_id"`
	QuestionID    uuid.UUID `json:"question_id"`
	QuestionOrder int32     `json:"question_order"`
	Content       string    `json:"content"`
	Options       []byte    `json:"options"`
	CorrectOption int32     `json:"correct_option"`
	Explanation   *string   `json:"explanation"`
}

func (q *Queries) ListGameQuestions(ctx context.Context, gameID uuid.UUID) ([]ListGameQuestionsRow, error) {
	rows, err := q.db.Query(ctx, listGameQuestions, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGameQuestionsRow{}
	for rows.Next() {
		var i ListGameQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.QuestionID,
			&i.QuestionOrder,
			&i.Content,
			&i.Options,
			&i.CorrectOption,
			&i.Explanation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlayerAnswersInRound = `-- name: ListPlayerAnswersInRound :many
SELECT 
    gra.id, gra.round_id, gra.player_id, gra.question_id, gra.selected_option, gra.is_correct, gra.answered_at,
    gq.question_order,
    q.content as question_content,
    q.options,
    q.correct_option
FROM game_round_answers gra
INNER JOIN game_questions gq ON gra.question_id = gq.id
INNER JOIN questions q ON gq.question_id = q.id
WHERE gra.round_id = $1 AND gra.player_id = $2
ORDER BY gq.question_order
`

type ListPlayerAnswersInRoundParams struct {
	RoundID  uuid.UUID `json:"round_id"`
	PlayerID uuid.UUID `json:"player_id"`
}

type ListPlayerAnswersInRoundRow struct {
	ID              uuid.UUID        `json:"id"`
	RoundID         uuid.UUID        `json:"round_id"`
	PlayerID        uuid.UUID        `json:"player_id"`
	QuestionID      uuid.UUID        `json:"question_id"`
	SelectedOption  int32            `json:"selected_option"`
	IsCorrect       bool             `json:"is_correct"`
	AnsweredAt      pgtype.Timestamp `json:"answered_at"`
	QuestionOrder   int32            `json:"question_order"`
	QuestionContent string           `json:"question_content"`
	Options         []byte           `json:"options"`
	CorrectOption   int32            `json:"correct_option"`
}

func (q *Queries) ListPlayerAnswersInRound(ctx context.Context, arg ListPlayerAnswersInRoundParams) ([]ListPlayerAnswersInRoundRow, error) {
	rows, err := q.db.Query(ctx, listPlayerAnswersInRound, arg.RoundID, arg.PlayerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPlayerAnswersInRoundRow{}
	for rows.Next() {
		var i ListPlayerAnswersInRoundRow
		if err := rows.Scan(
			&i.ID,
			&i.RoundID,
			&i.PlayerID,
			&i.QuestionID,
			&i.SelectedOption,
			&i.IsCorrect,
			&i.AnsweredAt,
			&i.QuestionOrder,
			&i.QuestionContent,
			&i.Options,
			&i.CorrectOption,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestions = `-- name: ListQuestions :many
SELECT id, content, options, correct_option, explanation, created_at, updated_at FROM questions
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type ListQuestionsParams struct {
	OffsetVal int32 `json:"offset_val"`
	LimitVal  int32 `json:"limit_val"`
}

func (q *Queries) ListQuestions(ctx context.Context, arg ListQuestionsParams) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestions, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Options,
			&i.CorrectOption,
			&i.Explanation,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoundAnswers = `-- name: ListRoundAnswers :many
SELECT 
    gra.id, gra.round_id, gra.player_id, gra.question_id, gra.selected_option, gra.is_correct, gra.answered_at,
    p.id as player_id,
    u.username,
    u.first_name,
    u.last_name,
    g.name as guest_name
FROM game_round_answers gra
INNER JOIN players p ON gra.player_id = p.id
LEFT JOIN users u ON p.user_id = u.id
LEFT JOIN guests g ON p.guest_id = g.id
WHERE gra.round_id = $1
ORDER BY gra.answered_at
`

type ListRoundAnswersRow struct {
	ID             uuid.UUID        `json:"id"`
	RoundID        uuid.UUID        `json:"round_id"`
	PlayerID       uuid.UUID        `json:"player_id"`
	QuestionID     uuid.UUID        `json:"question_id"`
	SelectedOption int32            `json:"selected_option"`
	IsCorrect      bool             `json:"is_correct"`
	AnsweredAt     pgtype.Timestamp `json:"answered_at"`
	PlayerID_2     uuid.UUID        `json:"player_id_2"`
	Username       *string          `json:"username"`
	FirstName      *string          `json:"first_name"`
	LastName       *string          `json:"last_name"`
	GuestName      *string          `json:"guest_name"`
}

func (q *Queries) ListRoundAnswers(ctx context.Context, roundID uuid.UUID) ([]ListRoundAnswersRow, error) {
	rows, err := q.db.Query(ctx, listRoundAnswers, roundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRoundAnswersRow{}
	for rows.Next() {
		var i ListRoundAnswersRow
		if err := rows.Scan(
			&i.ID,
			&i.RoundID,
			&i.PlayerID,
			&i.QuestionID,
			&i.SelectedOption,
			&i.IsCorrect,
			&i.AnsweredAt,
			&i.PlayerID_2,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.GuestName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT id, name, created_at FROM tags
ORDER BY name
LIMIT $2 OFFSET $1
`

type ListTagsParams struct {
	OffsetVal int32 `json:"offset_val"`
	LimitVal  int32 `json:"limit_val"`
}

func (q *Queries) ListTags(ctx context.Context, arg ListTagsParams) ([]Tag, error) {
	rows, err := q.db.Query(ctx, listTags, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeQuestionFromGame = `-- name: RemoveQuestionFromGame :exec
DELETE FROM game_questions
WHERE game_id = $1 AND question_id = $2
`

type RemoveQuestionFromGameParams struct {
	GameID     uuid.UUID `json:"game_id"`
	QuestionID uuid.UUID `json:"question_id"`
}

func (q *Queries) RemoveQuestionFromGame(ctx context.Context, arg RemoveQuestionFromGameParams) error {
	_, err := q.db.Exec(ctx, removeQuestionFromGame, arg.GameID, arg.QuestionID)
	return err
}

const removeTagFromQuestion = `-- name: RemoveTagFromQuestion :exec
DELETE FROM question_tags
WHERE question_id = $1 AND tag_id = $2
`

type RemoveTagFromQuestionParams struct {
	QuestionID uuid.UUID `json:"question_id"`
	TagID      uuid.UUID `json:"tag_id"`
}

func (q *Queries) RemoveTagFromQuestion(ctx context.Context, arg RemoveTagFromQuestionParams) error {
	_, err := q.db.Exec(ctx, removeTagFromQuestion, arg.QuestionID, arg.TagID)
	return err
}

const reorderGameQuestions = `-- name: ReorderGameQuestions :exec
UPDATE game_questions
SET question_order = $1
WHERE id = $2
`

type ReorderGameQuestionsParams struct {
	NewOrder int32     `json:"new_order"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) ReorderGameQuestions(ctx context.Context, arg ReorderGameQuestionsParams) error {
	_, err := q.db.Exec(ctx, reorderGameQuestions, arg.NewOrder, arg.ID)
	return err
}

const updateQuestion = `-- name: UpdateQuestion :one
UPDATE questions
SET 
    content = COALESCE($1, content),
    options = COALESCE($2, options),
    correct_option = COALESCE($3, correct_option),
    explanation = COALESCE($4, explanation),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $5
RETURNING id, content, options, correct_option, explanation, created_at, updated_at
`

type UpdateQuestionParams struct {
	Content       string    `json:"content"`
	Options       []byte    `json:"options"`
	CorrectOption int32     `json:"correct_option"`
	Explanation   *string   `json:"explanation"`
	ID            uuid.UUID `json:"id"`
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, updateQuestion,
		arg.Content,
		arg.Options,
		arg.CorrectOption,
		arg.Explanation,
		arg.ID,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.Options,
		&i.CorrectOption,
		&i.Explanation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
