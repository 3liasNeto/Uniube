// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: game.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addPlayerToGame = `-- name: AddPlayerToGame :one

INSERT INTO player_games (
    player_id, game_id, role
)
VALUES (
    $1, $2, $3
)
RETURNING id, player_id, game_id, role, joined_at, left_at, completed_at
`

type AddPlayerToGameParams struct {
	PlayerID uuid.UUID      `json:"player_id"`
	GameID   uuid.UUID      `json:"game_id"`
	Role     NullPlayerRole `json:"role"`
}

// ============================================
// PLAYER_GAMES QUERIES
// ============================================
func (q *Queries) AddPlayerToGame(ctx context.Context, arg AddPlayerToGameParams) (PlayerGame, error) {
	row := q.db.QueryRow(ctx, addPlayerToGame, arg.PlayerID, arg.GameID, arg.Role)
	var i PlayerGame
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.GameID,
		&i.Role,
		&i.JoinedAt,
		&i.LeftAt,
		&i.CompletedAt,
	)
	return i, err
}

const completePlayerGame = `-- name: CompletePlayerGame :exec
UPDATE player_games
SET completed_at = CURRENT_TIMESTAMP
WHERE player_id = $1 AND game_id = $2
`

type CompletePlayerGameParams struct {
	PlayerID uuid.UUID `json:"player_id"`
	GameID   uuid.UUID `json:"game_id"`
}

func (q *Queries) CompletePlayerGame(ctx context.Context, arg CompletePlayerGameParams) error {
	_, err := q.db.Exec(ctx, completePlayerGame, arg.PlayerID, arg.GameID)
	return err
}

const countGameRounds = `-- name: CountGameRounds :one
SELECT COUNT(*) FROM game_round
WHERE game_id = $1
`

func (q *Queries) CountGameRounds(ctx context.Context, gameID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countGameRounds, gameID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countGames = `-- name: CountGames :one
SELECT COUNT(*) FROM games
`

func (q *Queries) CountGames(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countGames)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countGamesByStatus = `-- name: CountGamesByStatus :one
SELECT COUNT(*) FROM games
WHERE status = $1
`

func (q *Queries) CountGamesByStatus(ctx context.Context, status NullGameStatus) (int64, error) {
	row := q.db.QueryRow(ctx, countGamesByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPlayersInGame = `-- name: CountPlayersInGame :one
SELECT COUNT(*) FROM player_games
WHERE game_id = $1 AND left_at IS NULL
`

func (q *Queries) CountPlayersInGame(ctx context.Context, gameID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPlayersInGame, gameID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGame = `-- name: CreateGame :one

INSERT INTO games (
    host_id, name, description, theme, status
)
VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, host_id, name, description, theme, status, created_at, updated_at, finished_at
`

type CreateGameParams struct {
	HostID      uuid.UUID      `json:"host_id"`
	Name        string         `json:"name"`
	Description *string        `json:"description"`
	Theme       *string        `json:"theme"`
	Status      NullGameStatus `json:"status"`
}

// ============================================
// GAMES QUERIES
// =============================================
func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRow(ctx, createGame,
		arg.HostID,
		arg.Name,
		arg.Description,
		arg.Theme,
		arg.Status,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.HostID,
		&i.Name,
		&i.Description,
		&i.Theme,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
	)
	return i, err
}

const createGameConfiguration = `-- name: CreateGameConfiguration :one

INSERT INTO game_configurations (
    game_id, time_per_question, randomize_questions, 
    streak_multiplier, streak_start, room_size, 
    questions_count, prompt
)
VALUES (
    $1, $2, $3,
    $4, $5, $6,
    $7, $8
)
RETURNING id, game_id, time_per_question, randomize_questions, streak_multiplier, streak_start, room_size, questions_count, prompt, created_at, updated_at
`

type CreateGameConfigurationParams struct {
	GameID             uuid.UUID `json:"game_id"`
	TimePerQuestion    *int32    `json:"time_per_question"`
	RandomizeQuestions *bool     `json:"randomize_questions"`
	StreakMultiplier   *int32    `json:"streak_multiplier"`
	StreakStart        *int32    `json:"streak_start"`
	RoomSize           *int32    `json:"room_size"`
	QuestionsCount     *int32    `json:"questions_count"`
	Prompt             []byte    `json:"prompt"`
}

// ============================================
// GAME_CONFIGURATIONS QUERIES
// ============================================
func (q *Queries) CreateGameConfiguration(ctx context.Context, arg CreateGameConfigurationParams) (GameConfiguration, error) {
	row := q.db.QueryRow(ctx, createGameConfiguration,
		arg.GameID,
		arg.TimePerQuestion,
		arg.RandomizeQuestions,
		arg.StreakMultiplier,
		arg.StreakStart,
		arg.RoomSize,
		arg.QuestionsCount,
		arg.Prompt,
	)
	var i GameConfiguration
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.TimePerQuestion,
		&i.RandomizeQuestions,
		&i.StreakMultiplier,
		&i.StreakStart,
		&i.RoomSize,
		&i.QuestionsCount,
		&i.Prompt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGameEvent = `-- name: CreateGameEvent :one

INSERT INTO game_events (
    game_id, event_type, event_data
)
VALUES (
    $1, $2, $3
)
RETURNING id, game_id, event_type, event_data, created_at
`

type CreateGameEventParams struct {
	GameID    uuid.UUID `json:"game_id"`
	EventType string    `json:"event_type"`
	EventData []byte    `json:"event_data"`
}

// ============================================
// GAME_EVENTS QUERIES
// ============================================
func (q *Queries) CreateGameEvent(ctx context.Context, arg CreateGameEventParams) (GameEvent, error) {
	row := q.db.QueryRow(ctx, createGameEvent, arg.GameID, arg.EventType, arg.EventData)
	var i GameEvent
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.EventType,
		&i.EventData,
		&i.CreatedAt,
	)
	return i, err
}

const createGameRound = `-- name: CreateGameRound :one

INSERT INTO game_round (
    game_id, round_number
)
VALUES (
    $1, $2
)
RETURNING id, game_id, round_number, started_at, ended_at
`

type CreateGameRoundParams struct {
	GameID      uuid.UUID `json:"game_id"`
	RoundNumber int32     `json:"round_number"`
}

// ============================================
// GAME_ROUND QUERIES
// ============================================
func (q *Queries) CreateGameRound(ctx context.Context, arg CreateGameRoundParams) (GameRound, error) {
	row := q.db.QueryRow(ctx, createGameRound, arg.GameID, arg.RoundNumber)
	var i GameRound
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.RoundNumber,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const createGameScore = `-- name: CreateGameScore :one

INSERT INTO game_scores (
    player_id, game_id, score, correct_answers, total_questions
)
VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, player_id, game_id, score, correct_answers, total_questions, position, created_at, updated_at
`

type CreateGameScoreParams struct {
	PlayerID       uuid.UUID `json:"player_id"`
	GameID         uuid.UUID `json:"game_id"`
	Score          *int32    `json:"score"`
	CorrectAnswers *int32    `json:"correct_answers"`
	TotalQuestions *int32    `json:"total_questions"`
}

// ============================================
// GAME_SCORES QUERIES
// ============================================
func (q *Queries) CreateGameScore(ctx context.Context, arg CreateGameScoreParams) (GameScore, error) {
	row := q.db.QueryRow(ctx, createGameScore,
		arg.PlayerID,
		arg.GameID,
		arg.Score,
		arg.CorrectAnswers,
		arg.TotalQuestions,
	)
	var i GameScore
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.GameID,
		&i.Score,
		&i.CorrectAnswers,
		&i.TotalQuestions,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGame = `-- name: DeleteGame :exec
DELETE FROM games
WHERE id = $1
`

func (q *Queries) DeleteGame(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteGame, id)
	return err
}

const deleteGameConfiguration = `-- name: DeleteGameConfiguration :exec
DELETE FROM game_configurations
WHERE game_id = $1
`

func (q *Queries) DeleteGameConfiguration(ctx context.Context, gameID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteGameConfiguration, gameID)
	return err
}

const deleteGameEvent = `-- name: DeleteGameEvent :exec
DELETE FROM game_events
WHERE id = $1
`

func (q *Queries) DeleteGameEvent(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteGameEvent, id)
	return err
}

const deleteGameEvents = `-- name: DeleteGameEvents :exec
DELETE FROM game_events
WHERE game_id = $1
`

func (q *Queries) DeleteGameEvents(ctx context.Context, gameID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteGameEvents, gameID)
	return err
}

const deleteGameRound = `-- name: DeleteGameRound :exec
DELETE FROM game_round
WHERE id = $1
`

func (q *Queries) DeleteGameRound(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteGameRound, id)
	return err
}

const deleteGameScore = `-- name: DeleteGameScore :exec
DELETE FROM game_scores
WHERE player_id = $1 AND game_id = $2
`

type DeleteGameScoreParams struct {
	PlayerID uuid.UUID `json:"player_id"`
	GameID   uuid.UUID `json:"game_id"`
}

func (q *Queries) DeleteGameScore(ctx context.Context, arg DeleteGameScoreParams) error {
	_, err := q.db.Exec(ctx, deleteGameScore, arg.PlayerID, arg.GameID)
	return err
}

const deletePlayerGame = `-- name: DeletePlayerGame :exec
DELETE FROM player_games
WHERE player_id = $1 AND game_id = $2
`

type DeletePlayerGameParams struct {
	PlayerID uuid.UUID `json:"player_id"`
	GameID   uuid.UUID `json:"game_id"`
}

func (q *Queries) DeletePlayerGame(ctx context.Context, arg DeletePlayerGameParams) error {
	_, err := q.db.Exec(ctx, deletePlayerGame, arg.PlayerID, arg.GameID)
	return err
}

const endGameRound = `-- name: EndGameRound :one
UPDATE game_round
SET ended_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, game_id, round_number, started_at, ended_at
`

func (q *Queries) EndGameRound(ctx context.Context, id uuid.UUID) (GameRound, error) {
	row := q.db.QueryRow(ctx, endGameRound, id)
	var i GameRound
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.RoundNumber,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const finishGame = `-- name: FinishGame :one
UPDATE games
SET 
    status = 'completed',
    finished_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, host_id, name, description, theme, status, created_at, updated_at, finished_at
`

func (q *Queries) FinishGame(ctx context.Context, id uuid.UUID) (Game, error) {
	row := q.db.QueryRow(ctx, finishGame, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.HostID,
		&i.Name,
		&i.Description,
		&i.Theme,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
	)
	return i, err
}

const getCurrentGameRound = `-- name: GetCurrentGameRound :one
SELECT id, game_id, round_number, started_at, ended_at FROM game_round
WHERE game_id = $1 AND ended_at IS NULL
ORDER BY round_number DESC
LIMIT 1
`

func (q *Queries) GetCurrentGameRound(ctx context.Context, gameID uuid.UUID) (GameRound, error) {
	row := q.db.QueryRow(ctx, getCurrentGameRound, gameID)
	var i GameRound
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.RoundNumber,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const getGameByID = `-- name: GetGameByID :one
SELECT id, host_id, name, description, theme, status, created_at, updated_at, finished_at FROM games
WHERE id = $1
`

func (q *Queries) GetGameByID(ctx context.Context, id uuid.UUID) (Game, error) {
	row := q.db.QueryRow(ctx, getGameByID, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.HostID,
		&i.Name,
		&i.Description,
		&i.Theme,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
	)
	return i, err
}

const getGameConfiguration = `-- name: GetGameConfiguration :one
SELECT id, game_id, time_per_question, randomize_questions, streak_multiplier, streak_start, room_size, questions_count, prompt, created_at, updated_at FROM game_configurations
WHERE game_id = $1
`

func (q *Queries) GetGameConfiguration(ctx context.Context, gameID uuid.UUID) (GameConfiguration, error) {
	row := q.db.QueryRow(ctx, getGameConfiguration, gameID)
	var i GameConfiguration
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.TimePerQuestion,
		&i.RandomizeQuestions,
		&i.StreakMultiplier,
		&i.StreakStart,
		&i.RoomSize,
		&i.QuestionsCount,
		&i.Prompt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGameEvent = `-- name: GetGameEvent :one
SELECT id, game_id, event_type, event_data, created_at FROM game_events
WHERE id = $1
`

func (q *Queries) GetGameEvent(ctx context.Context, id uuid.UUID) (GameEvent, error) {
	row := q.db.QueryRow(ctx, getGameEvent, id)
	var i GameEvent
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.EventType,
		&i.EventData,
		&i.CreatedAt,
	)
	return i, err
}

const getGameRound = `-- name: GetGameRound :one
SELECT id, game_id, round_number, started_at, ended_at FROM game_round
WHERE id = $1
`

func (q *Queries) GetGameRound(ctx context.Context, id uuid.UUID) (GameRound, error) {
	row := q.db.QueryRow(ctx, getGameRound, id)
	var i GameRound
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.RoundNumber,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const getGameRoundByNumber = `-- name: GetGameRoundByNumber :one
SELECT id, game_id, round_number, started_at, ended_at FROM game_round
WHERE game_id = $1 AND round_number = $2
`

type GetGameRoundByNumberParams struct {
	GameID      uuid.UUID `json:"game_id"`
	RoundNumber int32     `json:"round_number"`
}

func (q *Queries) GetGameRoundByNumber(ctx context.Context, arg GetGameRoundByNumberParams) (GameRound, error) {
	row := q.db.QueryRow(ctx, getGameRoundByNumber, arg.GameID, arg.RoundNumber)
	var i GameRound
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.RoundNumber,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const getGameScore = `-- name: GetGameScore :one
SELECT id, player_id, game_id, score, correct_answers, total_questions, position, created_at, updated_at FROM game_scores
WHERE player_id = $1 AND game_id = $2
`

type GetGameScoreParams struct {
	PlayerID uuid.UUID `json:"player_id"`
	GameID   uuid.UUID `json:"game_id"`
}

func (q *Queries) GetGameScore(ctx context.Context, arg GetGameScoreParams) (GameScore, error) {
	row := q.db.QueryRow(ctx, getGameScore, arg.PlayerID, arg.GameID)
	var i GameScore
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.GameID,
		&i.Score,
		&i.CorrectAnswers,
		&i.TotalQuestions,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGameScoreWithPlayerInfo = `-- name: GetGameScoreWithPlayerInfo :one
SELECT 
    gs.id, gs.player_id, gs.game_id, gs.score, gs.correct_answers, gs.total_questions, gs.position, gs.created_at, gs.updated_at,
    u.username,
    u.first_name,
    u.last_name,
    u.icon,
    g.name as guest_name
FROM game_scores gs
INNER JOIN players p ON gs.player_id = p.id
LEFT JOIN users u ON p.user_id = u.id
LEFT JOIN guests g ON p.guest_id = g.id
WHERE gs.player_id = $1 AND gs.game_id = $2
`

type GetGameScoreWithPlayerInfoParams struct {
	PlayerID uuid.UUID `json:"player_id"`
	GameID   uuid.UUID `json:"game_id"`
}

type GetGameScoreWithPlayerInfoRow struct {
	ID             uuid.UUID        `json:"id"`
	PlayerID       uuid.UUID        `json:"player_id"`
	GameID         uuid.UUID        `json:"game_id"`
	Score          *int32           `json:"score"`
	CorrectAnswers *int32           `json:"correct_answers"`
	TotalQuestions *int32           `json:"total_questions"`
	Position       *int32           `json:"position"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	Username       *string          `json:"username"`
	FirstName      *string          `json:"first_name"`
	LastName       *string          `json:"last_name"`
	Icon           *string          `json:"icon"`
	GuestName      *string          `json:"guest_name"`
}

func (q *Queries) GetGameScoreWithPlayerInfo(ctx context.Context, arg GetGameScoreWithPlayerInfoParams) (GetGameScoreWithPlayerInfoRow, error) {
	row := q.db.QueryRow(ctx, getGameScoreWithPlayerInfo, arg.PlayerID, arg.GameID)
	var i GetGameScoreWithPlayerInfoRow
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.GameID,
		&i.Score,
		&i.CorrectAnswers,
		&i.TotalQuestions,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Icon,
		&i.GuestName,
	)
	return i, err
}

const getGameWithHost = `-- name: GetGameWithHost :one
SELECT 
    g.id, g.host_id, g.name, g.description, g.theme, g.status, g.created_at, g.updated_at, g.finished_at,
    p.id as host_player_id,
    u.username as host_username,
    u.first_name as host_first_name,
    u.last_name as host_last_name,
    guest.name as host_guest_name
FROM games g
INNER JOIN players p ON g.host_id = p.id
LEFT JOIN users u ON p.user_id = u.id
LEFT JOIN guests guest ON p.guest_id = guest.id
WHERE g.id = $1
`

type GetGameWithHostRow struct {
	ID            uuid.UUID        `json:"id"`
	HostID        uuid.UUID        `json:"host_id"`
	Name          string           `json:"name"`
	Description   *string          `json:"description"`
	Theme         *string          `json:"theme"`
	Status        NullGameStatus   `json:"status"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	FinishedAt    pgtype.Timestamp `json:"finished_at"`
	HostPlayerID  uuid.UUID        `json:"host_player_id"`
	HostUsername  *string          `json:"host_username"`
	HostFirstName *string          `json:"host_first_name"`
	HostLastName  *string          `json:"host_last_name"`
	HostGuestName *string          `json:"host_guest_name"`
}

func (q *Queries) GetGameWithHost(ctx context.Context, id uuid.UUID) (GetGameWithHostRow, error) {
	row := q.db.QueryRow(ctx, getGameWithHost, id)
	var i GetGameWithHostRow
	err := row.Scan(
		&i.ID,
		&i.HostID,
		&i.Name,
		&i.Description,
		&i.Theme,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
		&i.HostPlayerID,
		&i.HostUsername,
		&i.HostFirstName,
		&i.HostLastName,
		&i.HostGuestName,
	)
	return i, err
}

const getPlayerGame = `-- name: GetPlayerGame :one
SELECT id, player_id, game_id, role, joined_at, left_at, completed_at FROM player_games
WHERE player_id = $1 AND game_id = $2
`

type GetPlayerGameParams struct {
	PlayerID uuid.UUID `json:"player_id"`
	GameID   uuid.UUID `json:"game_id"`
}

func (q *Queries) GetPlayerGame(ctx context.Context, arg GetPlayerGameParams) (PlayerGame, error) {
	row := q.db.QueryRow(ctx, getPlayerGame, arg.PlayerID, arg.GameID)
	var i PlayerGame
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.GameID,
		&i.Role,
		&i.JoinedAt,
		&i.LeftAt,
		&i.CompletedAt,
	)
	return i, err
}

const getTopScores = `-- name: GetTopScores :many
SELECT 
    gs.id, gs.player_id, gs.game_id, gs.score, gs.correct_answers, gs.total_questions, gs.position, gs.created_at, gs.updated_at,
    u.username,
    u.first_name,
    u.last_name,
    u.icon,
    g.name as guest_name,
    gm.name as game_name
FROM game_scores gs
INNER JOIN players p ON gs.player_id = p.id
INNER JOIN games gm ON gs.game_id = gm.id
LEFT JOIN users u ON p.user_id = u.id
LEFT JOIN guests g ON p.guest_id = g.id
ORDER BY gs.score DESC
LIMIT $1
`

type GetTopScoresRow struct {
	ID             uuid.UUID        `json:"id"`
	PlayerID       uuid.UUID        `json:"player_id"`
	GameID         uuid.UUID        `json:"game_id"`
	Score          *int32           `json:"score"`
	CorrectAnswers *int32           `json:"correct_answers"`
	TotalQuestions *int32           `json:"total_questions"`
	Position       *int32           `json:"position"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	Username       *string          `json:"username"`
	FirstName      *string          `json:"first_name"`
	LastName       *string          `json:"last_name"`
	Icon           *string          `json:"icon"`
	GuestName      *string          `json:"guest_name"`
	GameName       string           `json:"game_name"`
}

func (q *Queries) GetTopScores(ctx context.Context, limitVal int32) ([]GetTopScoresRow, error) {
	rows, err := q.db.Query(ctx, getTopScores, limitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopScoresRow{}
	for rows.Next() {
		var i GetTopScoresRow
		if err := rows.Scan(
			&i.ID,
			&i.PlayerID,
			&i.GameID,
			&i.Score,
			&i.CorrectAnswers,
			&i.TotalQuestions,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.Icon,
			&i.GuestName,
			&i.GameName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementGameScore = `-- name: IncrementGameScore :one
UPDATE game_scores
SET 
    score = score + $1,
    correct_answers = correct_answers + $2,
    total_questions = total_questions + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE player_id = $3 AND game_id = $4
RETURNING id, player_id, game_id, score, correct_answers, total_questions, position, created_at, updated_at
`

type IncrementGameScoreParams struct {
	Points           *int32    `json:"points"`
	CorrectIncrement *int32    `json:"correct_increment"`
	PlayerID         uuid.UUID `json:"player_id"`
	GameID           uuid.UUID `json:"game_id"`
}

func (q *Queries) IncrementGameScore(ctx context.Context, arg IncrementGameScoreParams) (GameScore, error) {
	row := q.db.QueryRow(ctx, incrementGameScore,
		arg.Points,
		arg.CorrectIncrement,
		arg.PlayerID,
		arg.GameID,
	)
	var i GameScore
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.GameID,
		&i.Score,
		&i.CorrectAnswers,
		&i.TotalQuestions,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listGameEvents = `-- name: ListGameEvents :many
SELECT id, game_id, event_type, event_data, created_at FROM game_events
WHERE game_id = $1
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type ListGameEventsParams struct {
	GameID    uuid.UUID `json:"game_id"`
	OffsetVal int32     `json:"offset_val"`
	LimitVal  int32     `json:"limit_val"`
}

func (q *Queries) ListGameEvents(ctx context.Context, arg ListGameEventsParams) ([]GameEvent, error) {
	rows, err := q.db.Query(ctx, listGameEvents, arg.GameID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GameEvent{}
	for rows.Next() {
		var i GameEvent
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.EventType,
			&i.EventData,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGameEventsByType = `-- name: ListGameEventsByType :many
SELECT id, game_id, event_type, event_data, created_at FROM game_events
WHERE game_id = $1 AND event_type = $2
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

type ListGameEventsByTypeParams struct {
	GameID    uuid.UUID `json:"game_id"`
	EventType string    `json:"event_type"`
	OffsetVal int32     `json:"offset_val"`
	LimitVal  int32     `json:"limit_val"`
}

func (q *Queries) ListGameEventsByType(ctx context.Context, arg ListGameEventsByTypeParams) ([]GameEvent, error) {
	rows, err := q.db.Query(ctx, listGameEventsByType,
		arg.GameID,
		arg.EventType,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GameEvent{}
	for rows.Next() {
		var i GameEvent
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.EventType,
			&i.EventData,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGameRounds = `-- name: ListGameRounds :many
SELECT id, game_id, round_number, started_at, ended_at FROM game_round
WHERE game_id = $1
ORDER BY round_number
`

func (q *Queries) ListGameRounds(ctx context.Context, gameID uuid.UUID) ([]GameRound, error) {
	rows, err := q.db.Query(ctx, listGameRounds, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GameRound{}
	for rows.Next() {
		var i GameRound
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.RoundNumber,
			&i.StartedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGameScores = `-- name: ListGameScores :many
SELECT 
    gs.id, gs.player_id, gs.game_id, gs.score, gs.correct_answers, gs.total_questions, gs.position, gs.created_at, gs.updated_at,
    u.username,
    u.first_name,
    u.last_name,
    u.icon,
    g.name as guest_name
FROM game_scores gs
INNER JOIN players p ON gs.player_id = p.id
LEFT JOIN users u ON p.user_id = u.id
LEFT JOIN guests g ON p.guest_id = g.id
WHERE gs.game_id = $1
ORDER BY gs.score DESC, gs.created_at ASC
`

type ListGameScoresRow struct {
	ID             uuid.UUID        `json:"id"`
	PlayerID       uuid.UUID        `json:"player_id"`
	GameID         uuid.UUID        `json:"game_id"`
	Score          *int32           `json:"score"`
	CorrectAnswers *int32           `json:"correct_answers"`
	TotalQuestions *int32           `json:"total_questions"`
	Position       *int32           `json:"position"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	Username       *string          `json:"username"`
	FirstName      *string          `json:"first_name"`
	LastName       *string          `json:"last_name"`
	Icon           *string          `json:"icon"`
	GuestName      *string          `json:"guest_name"`
}

func (q *Queries) ListGameScores(ctx context.Context, gameID uuid.UUID) ([]ListGameScoresRow, error) {
	rows, err := q.db.Query(ctx, listGameScores, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGameScoresRow{}
	for rows.Next() {
		var i ListGameScoresRow
		if err := rows.Scan(
			&i.ID,
			&i.PlayerID,
			&i.GameID,
			&i.Score,
			&i.CorrectAnswers,
			&i.TotalQuestions,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.Icon,
			&i.GuestName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGames = `-- name: ListGames :many
SELECT id, host_id, name, description, theme, status, created_at, updated_at, finished_at FROM games
WHERE host_id = $1 OR status = $2
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

type ListGamesParams struct {
	HostID    uuid.UUID      `json:"host_id"`
	Status    NullGameStatus `json:"status"`
	OffsetVal int32          `json:"offset_val"`
	LimitVal  int32          `json:"limit_val"`
}

func (q *Queries) ListGames(ctx context.Context, arg ListGamesParams) ([]Game, error) {
	rows, err := q.db.Query(ctx, listGames,
		arg.HostID,
		arg.Status,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Game{}
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.HostID,
			&i.Name,
			&i.Description,
			&i.Theme,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGamesByPlayer = `-- name: ListGamesByPlayer :many
SELECT 
    g.id, g.host_id, g.name, g.description, g.theme, g.status, g.created_at, g.updated_at, g.finished_at,
    pg.role,
    pg.joined_at,
    pg.completed_at
FROM games g
INNER JOIN player_games pg ON g.id = pg.game_id
WHERE pg.player_id = $1
ORDER BY pg.joined_at DESC
LIMIT $3 OFFSET $2
`

type ListGamesByPlayerParams struct {
	PlayerID  uuid.UUID `json:"player_id"`
	OffsetVal int32     `json:"offset_val"`
	LimitVal  int32     `json:"limit_val"`
}

type ListGamesByPlayerRow struct {
	ID          uuid.UUID        `json:"id"`
	HostID      uuid.UUID        `json:"host_id"`
	Name        string           `json:"name"`
	Description *string          `json:"description"`
	Theme       *string          `json:"theme"`
	Status      NullGameStatus   `json:"status"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	FinishedAt  pgtype.Timestamp `json:"finished_at"`
	Role        NullPlayerRole   `json:"role"`
	JoinedAt    pgtype.Timestamp `json:"joined_at"`
	CompletedAt pgtype.Timestamp `json:"completed_at"`
}

func (q *Queries) ListGamesByPlayer(ctx context.Context, arg ListGamesByPlayerParams) ([]ListGamesByPlayerRow, error) {
	rows, err := q.db.Query(ctx, listGamesByPlayer, arg.PlayerID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGamesByPlayerRow{}
	for rows.Next() {
		var i ListGamesByPlayerRow
		if err := rows.Scan(
			&i.ID,
			&i.HostID,
			&i.Name,
			&i.Description,
			&i.Theme,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinishedAt,
			&i.Role,
			&i.JoinedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlayerScores = `-- name: ListPlayerScores :many
SELECT 
    gs.id, gs.player_id, gs.game_id, gs.score, gs.correct_answers, gs.total_questions, gs.position, gs.created_at, gs.updated_at,
    gm.name as game_name,
    gm.theme as game_theme
FROM game_scores gs
INNER JOIN games gm ON gs.game_id = gm.id
WHERE gs.player_id = $1
ORDER BY gs.created_at DESC
LIMIT $3 OFFSET $2
`

type ListPlayerScoresParams struct {
	PlayerID  uuid.UUID `json:"player_id"`
	OffsetVal int32     `json:"offset_val"`
	LimitVal  int32     `json:"limit_val"`
}

type ListPlayerScoresRow struct {
	ID             uuid.UUID        `json:"id"`
	PlayerID       uuid.UUID        `json:"player_id"`
	GameID         uuid.UUID        `json:"game_id"`
	Score          *int32           `json:"score"`
	CorrectAnswers *int32           `json:"correct_answers"`
	TotalQuestions *int32           `json:"total_questions"`
	Position       *int32           `json:"position"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	GameName       string           `json:"game_name"`
	GameTheme      *string          `json:"game_theme"`
}

func (q *Queries) ListPlayerScores(ctx context.Context, arg ListPlayerScoresParams) ([]ListPlayerScoresRow, error) {
	rows, err := q.db.Query(ctx, listPlayerScores, arg.PlayerID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPlayerScoresRow{}
	for rows.Next() {
		var i ListPlayerScoresRow
		if err := rows.Scan(
			&i.ID,
			&i.PlayerID,
			&i.GameID,
			&i.Score,
			&i.CorrectAnswers,
			&i.TotalQuestions,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GameName,
			&i.GameTheme,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlayersInGame = `-- name: ListPlayersInGame :many
SELECT 
    pg.id, pg.player_id, pg.game_id, pg.role, pg.joined_at, pg.left_at, pg.completed_at,
    p.id as player_id,
    u.username,
    u.first_name,
    u.last_name,
    u.icon,
    g.name as guest_name
FROM player_games pg
INNER JOIN players p ON pg.player_id = p.id
LEFT JOIN users u ON p.user_id = u.id
LEFT JOIN guests g ON p.guest_id = g.id
WHERE pg.game_id = $1
ORDER BY pg.joined_at
`

type ListPlayersInGameRow struct {
	ID          uuid.UUID        `json:"id"`
	PlayerID    uuid.UUID        `json:"player_id"`
	GameID      uuid.UUID        `json:"game_id"`
	Role        NullPlayerRole   `json:"role"`
	JoinedAt    pgtype.Timestamp `json:"joined_at"`
	LeftAt      pgtype.Timestamp `json:"left_at"`
	CompletedAt pgtype.Timestamp `json:"completed_at"`
	PlayerID_2  uuid.UUID        `json:"player_id_2"`
	Username    *string          `json:"username"`
	FirstName   *string          `json:"first_name"`
	LastName    *string          `json:"last_name"`
	Icon        *string          `json:"icon"`
	GuestName   *string          `json:"guest_name"`
}

func (q *Queries) ListPlayersInGame(ctx context.Context, gameID uuid.UUID) ([]ListPlayersInGameRow, error) {
	rows, err := q.db.Query(ctx, listPlayersInGame, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPlayersInGameRow{}
	for rows.Next() {
		var i ListPlayersInGameRow
		if err := rows.Scan(
			&i.ID,
			&i.PlayerID,
			&i.GameID,
			&i.Role,
			&i.JoinedAt,
			&i.LeftAt,
			&i.CompletedAt,
			&i.PlayerID_2,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.Icon,
			&i.GuestName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePlayerFromGame = `-- name: RemovePlayerFromGame :exec
UPDATE player_games
SET left_at = CURRENT_TIMESTAMP
WHERE player_id = $1 AND game_id = $2
`

type RemovePlayerFromGameParams struct {
	PlayerID uuid.UUID `json:"player_id"`
	GameID   uuid.UUID `json:"game_id"`
}

func (q *Queries) RemovePlayerFromGame(ctx context.Context, arg RemovePlayerFromGameParams) error {
	_, err := q.db.Exec(ctx, removePlayerFromGame, arg.PlayerID, arg.GameID)
	return err
}

const startGame = `-- name: StartGame :one
UPDATE games
SET 
    status = 'in_progress',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, host_id, name, description, theme, status, created_at, updated_at, finished_at
`

func (q *Queries) StartGame(ctx context.Context, id uuid.UUID) (Game, error) {
	row := q.db.QueryRow(ctx, startGame, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.HostID,
		&i.Name,
		&i.Description,
		&i.Theme,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
	)
	return i, err
}

const updateGame = `-- name: UpdateGame :one
UPDATE games
SET 
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    theme = COALESCE($3, theme),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $4
RETURNING id, host_id, name, description, theme, status, created_at, updated_at, finished_at
`

type UpdateGameParams struct {
	Name        string    `json:"name"`
	Description *string   `json:"description"`
	Theme       *string   `json:"theme"`
	ID          uuid.UUID `json:"id"`
}

func (q *Queries) UpdateGame(ctx context.Context, arg UpdateGameParams) (Game, error) {
	row := q.db.QueryRow(ctx, updateGame,
		arg.Name,
		arg.Description,
		arg.Theme,
		arg.ID,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.HostID,
		&i.Name,
		&i.Description,
		&i.Theme,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
	)
	return i, err
}

const updateGameConfiguration = `-- name: UpdateGameConfiguration :one
UPDATE game_configurations
SET 
    time_per_question = COALESCE($1, time_per_question),
    randomize_questions = COALESCE($2, randomize_questions),
    streak_multiplier = COALESCE($3, streak_multiplier),
    streak_start = COALESCE($4, streak_start),
    room_size = COALESCE($5, room_size),
    questions_count = COALESCE($6, questions_count),
    prompt = COALESCE($7, prompt),
    updated_at = CURRENT_TIMESTAMP
WHERE game_id = $8
RETURNING id, game_id, time_per_question, randomize_questions, streak_multiplier, streak_start, room_size, questions_count, prompt, created_at, updated_at
`

type UpdateGameConfigurationParams struct {
	TimePerQuestion    *int32    `json:"time_per_question"`
	RandomizeQuestions *bool     `json:"randomize_questions"`
	StreakMultiplier   *int32    `json:"streak_multiplier"`
	StreakStart        *int32    `json:"streak_start"`
	RoomSize           *int32    `json:"room_size"`
	QuestionsCount     *int32    `json:"questions_count"`
	Prompt             []byte    `json:"prompt"`
	GameID             uuid.UUID `json:"game_id"`
}

func (q *Queries) UpdateGameConfiguration(ctx context.Context, arg UpdateGameConfigurationParams) (GameConfiguration, error) {
	row := q.db.QueryRow(ctx, updateGameConfiguration,
		arg.TimePerQuestion,
		arg.RandomizeQuestions,
		arg.StreakMultiplier,
		arg.StreakStart,
		arg.RoomSize,
		arg.QuestionsCount,
		arg.Prompt,
		arg.GameID,
	)
	var i GameConfiguration
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.TimePerQuestion,
		&i.RandomizeQuestions,
		&i.StreakMultiplier,
		&i.StreakStart,
		&i.RoomSize,
		&i.QuestionsCount,
		&i.Prompt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGameScore = `-- name: UpdateGameScore :one
UPDATE game_scores
SET 
    score = $1,
    correct_answers = $2,
    total_questions = $3,
    position = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE player_id = $5 AND game_id = $6
RETURNING id, player_id, game_id, score, correct_answers, total_questions, position, created_at, updated_at
`

type UpdateGameScoreParams struct {
	Score          *int32    `json:"score"`
	CorrectAnswers *int32    `json:"correct_answers"`
	TotalQuestions *int32    `json:"total_questions"`
	Position       *int32    `json:"position"`
	PlayerID       uuid.UUID `json:"player_id"`
	GameID         uuid.UUID `json:"game_id"`
}

func (q *Queries) UpdateGameScore(ctx context.Context, arg UpdateGameScoreParams) (GameScore, error) {
	row := q.db.QueryRow(ctx, updateGameScore,
		arg.Score,
		arg.CorrectAnswers,
		arg.TotalQuestions,
		arg.Position,
		arg.PlayerID,
		arg.GameID,
	)
	var i GameScore
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.GameID,
		&i.Score,
		&i.CorrectAnswers,
		&i.TotalQuestions,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGameScorePosition = `-- name: UpdateGameScorePosition :exec
UPDATE game_scores
SET 
    position = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE player_id = $2 AND game_id = $3
`

type UpdateGameScorePositionParams struct {
	Position *int32    `json:"position"`
	PlayerID uuid.UUID `json:"player_id"`
	GameID   uuid.UUID `json:"game_id"`
}

func (q *Queries) UpdateGameScorePosition(ctx context.Context, arg UpdateGameScorePositionParams) error {
	_, err := q.db.Exec(ctx, updateGameScorePosition, arg.Position, arg.PlayerID, arg.GameID)
	return err
}

const updateGameStatus = `-- name: UpdateGameStatus :one
UPDATE games
SET 
    status = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $2
RETURNING id, host_id, name, description, theme, status, created_at, updated_at, finished_at
`

type UpdateGameStatusParams struct {
	Status NullGameStatus `json:"status"`
	ID     uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateGameStatus(ctx context.Context, arg UpdateGameStatusParams) (Game, error) {
	row := q.db.QueryRow(ctx, updateGameStatus, arg.Status, arg.ID)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.HostID,
		&i.Name,
		&i.Description,
		&i.Theme,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
	)
	return i, err
}
