// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countPlayers = `-- name: CountPlayers :one
SELECT COUNT(*) FROM players
`

func (q *Queries) CountPlayers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPlayers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users
WHERE deleted_at IS NULL
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGuest = `-- name: CreateGuest :one

INSERT INTO guests (name, session_token)
VALUES ($1, $2)
RETURNING id, name, session_token, created_at, updated_at
`

type CreateGuestParams struct {
	Name         string `json:"name"`
	SessionToken string `json:"session_token"`
}

// ============================================
// GUESTS QUERIES
// ============================================
func (q *Queries) CreateGuest(ctx context.Context, arg CreateGuestParams) (Guest, error) {
	row := q.db.QueryRow(ctx, createGuest, arg.Name, arg.SessionToken)
	var i Guest
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SessionToken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPlayerFromGuest = `-- name: CreatePlayerFromGuest :one
INSERT INTO players (guest_id)
VALUES ($1)
RETURNING id, user_id, guest_id, total_quizzes_taken, created_at, updated_at
`

func (q *Queries) CreatePlayerFromGuest(ctx context.Context, guestID pgtype.UUID) (Player, error) {
	row := q.db.QueryRow(ctx, createPlayerFromGuest, guestID)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GuestID,
		&i.TotalQuizzesTaken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPlayerFromUser = `-- name: CreatePlayerFromUser :one

INSERT INTO players (user_id)
VALUES ($1)
RETURNING id, user_id, guest_id, total_quizzes_taken, created_at, updated_at
`

// ============================================
// PLAYERS QUERIES
// ============================================
func (q *Queries) CreatePlayerFromUser(ctx context.Context, userID pgtype.UUID) (Player, error) {
	row := q.db.QueryRow(ctx, createPlayerFromUser, userID)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GuestID,
		&i.TotalQuizzesTaken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    username, first_name, last_name, email, password, icon
)
VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, username, first_name, last_name, email, password, icon, created_at, updated_at, deleted_at
`

type CreateUserParams struct {
	Username  string  `json:"username"`
	FirstName string  `json:"first_name"`
	LastName  string  `json:"last_name"`
	Email     string  `json:"email"`
	Password  string  `json:"password"`
	Icon      *string `json:"icon"`
}

// ============================================
// USER QUERIES
// =============================================
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Password,
		arg.Icon,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteGuest = `-- name: DeleteGuest :exec
DELETE FROM guests
WHERE id = $1
`

func (q *Queries) DeleteGuest(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteGuest, id)
	return err
}

const deletePlayer = `-- name: DeletePlayer :exec
DELETE FROM players
WHERE id = $1
`

func (q *Queries) DeletePlayer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePlayer, id)
	return err
}

const getGuestByID = `-- name: GetGuestByID :one
SELECT id, name, session_token, created_at, updated_at FROM guests
WHERE id = $1
`

func (q *Queries) GetGuestByID(ctx context.Context, id uuid.UUID) (Guest, error) {
	row := q.db.QueryRow(ctx, getGuestByID, id)
	var i Guest
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SessionToken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGuestBySessionToken = `-- name: GetGuestBySessionToken :one
SELECT id, name, session_token, created_at, updated_at FROM guests
WHERE session_token = $1
`

func (q *Queries) GetGuestBySessionToken(ctx context.Context, sessionToken string) (Guest, error) {
	row := q.db.QueryRow(ctx, getGuestBySessionToken, sessionToken)
	var i Guest
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SessionToken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerByGuestID = `-- name: GetPlayerByGuestID :one
SELECT id, user_id, guest_id, total_quizzes_taken, created_at, updated_at FROM players
WHERE guest_id = $1
`

func (q *Queries) GetPlayerByGuestID(ctx context.Context, guestID pgtype.UUID) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayerByGuestID, guestID)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GuestID,
		&i.TotalQuizzesTaken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerByID = `-- name: GetPlayerByID :one
SELECT id, user_id, guest_id, total_quizzes_taken, created_at, updated_at FROM players
WHERE id = $1
`

func (q *Queries) GetPlayerByID(ctx context.Context, id uuid.UUID) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayerByID, id)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GuestID,
		&i.TotalQuizzesTaken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerByUserID = `-- name: GetPlayerByUserID :one
SELECT id, user_id, guest_id, total_quizzes_taken, created_at, updated_at FROM players
WHERE user_id = $1
`

func (q *Queries) GetPlayerByUserID(ctx context.Context, userID pgtype.UUID) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayerByUserID, userID)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GuestID,
		&i.TotalQuizzesTaken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerStats = `-- name: GetPlayerStats :one
SELECT 
    p.id,
    p.total_quizzes_taken,
    COUNT(DISTINCT pg.game_id) as total_games_played,
    COALESCE(AVG(gs.score), 0) as average_score,
    COALESCE(MAX(gs.score), 0) as best_score,
    COALESCE(SUM(gs.correct_answers), 0) as total_correct_answers,
    COALESCE(SUM(gs.total_questions), 0) as total_questions_answered
FROM players p
LEFT JOIN player_games pg ON p.id = pg.player_id
LEFT JOIN game_scores gs ON p.id = gs.player_id
WHERE p.id = $1
GROUP BY p.id, p.total_quizzes_taken
`

type GetPlayerStatsRow struct {
	ID                     uuid.UUID   `json:"id"`
	TotalQuizzesTaken      *int32      `json:"total_quizzes_taken"`
	TotalGamesPlayed       int64       `json:"total_games_played"`
	AverageScore           interface{} `json:"average_score"`
	BestScore              interface{} `json:"best_score"`
	TotalCorrectAnswers    interface{} `json:"total_correct_answers"`
	TotalQuestionsAnswered interface{} `json:"total_questions_answered"`
}

func (q *Queries) GetPlayerStats(ctx context.Context, id uuid.UUID) (GetPlayerStatsRow, error) {
	row := q.db.QueryRow(ctx, getPlayerStats, id)
	var i GetPlayerStatsRow
	err := row.Scan(
		&i.ID,
		&i.TotalQuizzesTaken,
		&i.TotalGamesPlayed,
		&i.AverageScore,
		&i.BestScore,
		&i.TotalCorrectAnswers,
		&i.TotalQuestionsAnswered,
	)
	return i, err
}

const getPlayerWithUserInfo = `-- name: GetPlayerWithUserInfo :one
SELECT 
    p.id, p.user_id, p.guest_id, p.total_quizzes_taken, p.created_at, p.updated_at,
    u.username,
    u.first_name,
    u.last_name,
    u.email,
    u.icon as user_icon,
    g.name as guest_name
FROM players p
LEFT JOIN users u ON p.user_id = u.id
LEFT JOIN guests g ON p.guest_id = g.id
WHERE p.id = $1
`

type GetPlayerWithUserInfoRow struct {
	ID                uuid.UUID        `json:"id"`
	UserID            pgtype.UUID      `json:"user_id"`
	GuestID           pgtype.UUID      `json:"guest_id"`
	TotalQuizzesTaken *int32           `json:"total_quizzes_taken"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	Username          *string          `json:"username"`
	FirstName         *string          `json:"first_name"`
	LastName          *string          `json:"last_name"`
	Email             *string          `json:"email"`
	UserIcon          *string          `json:"user_icon"`
	GuestName         *string          `json:"guest_name"`
}

func (q *Queries) GetPlayerWithUserInfo(ctx context.Context, id uuid.UUID) (GetPlayerWithUserInfoRow, error) {
	row := q.db.QueryRow(ctx, getPlayerWithUserInfo, id)
	var i GetPlayerWithUserInfoRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GuestID,
		&i.TotalQuizzesTaken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.UserIcon,
		&i.GuestName,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, first_name, last_name, email, password, icon, created_at, updated_at, deleted_at FROM users
WHERE email = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, first_name, last_name, email, password, icon, created_at, updated_at, deleted_at FROM users
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, first_name, last_name, email, password, icon, created_at, updated_at, deleted_at FROM users
WHERE username = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const hardDeleteUser = `-- name: HardDeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) HardDeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteUser, id)
	return err
}

const listGuests = `-- name: ListGuests :many
SELECT id, name, session_token, created_at, updated_at FROM guests
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type ListGuestsParams struct {
	OffsetVal int32 `json:"offset_val"`
	LimitVal  int32 `json:"limit_val"`
}

func (q *Queries) ListGuests(ctx context.Context, arg ListGuestsParams) ([]Guest, error) {
	rows, err := q.db.Query(ctx, listGuests, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Guest{}
	for rows.Next() {
		var i Guest
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.SessionToken,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlayers = `-- name: ListPlayers :many
SELECT 
    p.id, p.user_id, p.guest_id, p.total_quizzes_taken, p.created_at, p.updated_at,
    u.username,
    u.first_name,
    u.last_name,
    g.name as guest_name
FROM players p
LEFT JOIN users u ON p.user_id = u.id
LEFT JOIN guests g ON p.guest_id = g.id
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $1
`

type ListPlayersParams struct {
	OffsetVal int32 `json:"offset_val"`
	LimitVal  int32 `json:"limit_val"`
}

type ListPlayersRow struct {
	ID                uuid.UUID        `json:"id"`
	UserID            pgtype.UUID      `json:"user_id"`
	GuestID           pgtype.UUID      `json:"guest_id"`
	TotalQuizzesTaken *int32           `json:"total_quizzes_taken"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	Username          *string          `json:"username"`
	FirstName         *string          `json:"first_name"`
	LastName          *string          `json:"last_name"`
	GuestName         *string          `json:"guest_name"`
}

func (q *Queries) ListPlayers(ctx context.Context, arg ListPlayersParams) ([]ListPlayersRow, error) {
	rows, err := q.db.Query(ctx, listPlayers, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPlayersRow{}
	for rows.Next() {
		var i ListPlayersRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GuestID,
			&i.TotalQuizzesTaken,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.GuestName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, first_name, last_name, email, password, icon, created_at, updated_at, deleted_at FROM users
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type ListUsersParams struct {
	OffsetVal int32 `json:"offset_val"`
	LimitVal  int32 `json:"limit_val"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Password,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsersByUsername = `-- name: SearchUsersByUsername :many
SELECT id, username, first_name, last_name, email, password, icon, created_at, updated_at, deleted_at FROM users
WHERE username ILIKE '%' || $1 || '%'
  AND deleted_at IS NULL
ORDER BY username
LIMIT $2
`

type SearchUsersByUsernameParams struct {
	SearchTerm *string `json:"search_term"`
	LimitVal   int32   `json:"limit_val"`
}

func (q *Queries) SearchUsersByUsername(ctx context.Context, arg SearchUsersByUsernameParams) ([]User, error) {
	rows, err := q.db.Query(ctx, searchUsersByUsername, arg.SearchTerm, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Password,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteUser = `-- name: SoftDeleteUser :exec
UPDATE users
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) SoftDeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteUser, id)
	return err
}

const updatePlayerQuizzesTaken = `-- name: UpdatePlayerQuizzesTaken :exec
UPDATE players
SET 
    total_quizzes_taken = total_quizzes_taken + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) UpdatePlayerQuizzesTaken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updatePlayerQuizzesTaken, id)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET 
    username = COALESCE($1, username),
    first_name = COALESCE($2, first_name),
    last_name = COALESCE($3, last_name),
    email = COALESCE($4, email),
    icon = COALESCE($5, icon),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $6 AND deleted_at IS NULL
RETURNING id, username, first_name, last_name, email, password, icon, created_at, updated_at, deleted_at
`

type UpdateUserParams struct {
	Username  string    `json:"username"`
	FirstName string    `json:"first_name"`
	LastName  string    `json:"last_name"`
	Email     string    `json:"email"`
	Icon      *string   `json:"icon"`
	ID        uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Icon,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET 
    password = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $2 AND deleted_at IS NULL
`

type UpdateUserPasswordParams struct {
	Password string    `json:"password"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.Password, arg.ID)
	return err
}
